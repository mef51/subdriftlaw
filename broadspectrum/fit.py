#!/usr/bin/python
from __future__ import division
import math
import os
import sys
import time
import numpy as np
import scipy.stats
from scipy.optimize import curve_fit
from math import log10
import matplotlib.pyplot as plt
import matplotlib.cm as cm
from scipy import pi as nombrepi
from lmfit import Model
from lmfit.models import GaussianModel
from lmfit.models import LorentzianModel
from lmfit.models import VoigtModel
from lmfit.models import ConstantModel
import matplotlib


##### Read the data file automatical generated by ecriture_input ####

donnees = open("input.dat","r")

lignes = donnees.readlines()

donnees.close()

##### Vector initialization #######

s = len(lignes) # Number of points #

f = np.zeros(s)

I = np.zeros(s)

variance = np.zeros(s)

# data = str(input("Numero de plot : "))
data = 16

##### Choix de la plage de frequences et remplissage des tableaux
# go from 28ish to 472ish for victor's plot
# fmin = float(input("Minimal frequency : "))
fmin = 28

# fmax = float(input("Maximal frequency : "))
fmax = 472

#### Here when you will have enter fmin and fmax, it will choose the right range of data to operate on

for i in range(1,s+1) :

	f[i-1] = float(lignes[i-1].split()[0])
	I[i-1] = float(lignes[i-1].split()[1])
	variance[i-1] = float(lignes[i-1].split()[2])


	if (f[i-1] <= fmin) :

		indicemin = i-1

	if (f[i-1] <= fmax) :

		indicemax = i-1

n = indicemax-indicemin+1 # Number of points of the right frequency range

frequence = np.zeros(n)

intensite = np.zeros(n)

new_variance = np.zeros(n)

for i in range(1,n+1) :

	new_variance[i-1] = variance[indicemin+(i-1)]

	frequence[i-1] = f[indicemin+(i-1)]

	intensite[i-1] = I[indicemin+(i-1)]

##### Calcul des grandeurs propres au signal

esperance_signal = sum(frequence*intensite)/sum(intensite)

variance_signal = np.sqrt(sum(intensite*(frequence-esperance_signal)**2)/sum(intensite))

##### Definition de la fonction fit gaussienne ou Lorentzienne (pas)

def gaussienne(x,b,a,xo,sigma) :
	return b+a*np.exp(-(x-xo)**2/(2*(sigma**2)))

##### Here you can choose what fit is best betwwenn a Gaussian (defined before, so that you can put more than one
##### or a Gaussian (one only) + constant

gmodel = Model(gaussienne)
result = gmodel.fit(intensite,x = frequence,b=0,a=np.max(intensite),xo=esperance_signal,sigma=variance_signal,method='leastsq')
print(result.fit_report())

mod = GaussianModel()+ConstantModel()
out = mod.fit(intensite, x=frequence,amplitude=np.max(intensite),center=esperance_signal,sigma=variance_signal,c=0)
print(out.fit_report(min_correl=0.25))


##### Plot

starfreq = 4.2e9 # Hz
restfreq = 4.55e9 # Hz
freqwidth = 1.5625e6 # Hz
realfrequency = starfreq + frequence*freqwidth

velocity = 3e8 * (realfrequency - restfreq) / restfreq # m/s
velocity = velocity/1000

matplotlib.rcParams['legend.handlelength'] = 0
matplotlib.rcParams['legend.numpoints'] = 1

plt.plot(velocity,intensite,'k-',label = 'Burst 16, Michilli et al. (2018)')
# plt.plot(frequence,gaussienne(frequence,*parametres),'r',label = 'fit')
# plt.plot(frequence,out.init_fit,'b--')
# plt.plot(frequence,result.best_fit,'g')
# plt.plot(frequence,out.best_fit,'r-')
plt.legend()
# plt.title("Burst #%s Spectra"%data)
plt.xlabel("Velocity (km/s)")
plt.ylabel("Flux Density (Jy)")
plt.xlim([-22000, 28000])
plt.ylim([-0.05, 1.0])
# plt.show()
plt.savefig("burst16spectra.pdf")
